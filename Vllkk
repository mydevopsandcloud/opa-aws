package wiz.cspm.ecr_public_repository_policy

import rego.v1

# Rule metadata
rule_id := "ECR_PUBLIC_REPO_PUTIMAGE_POLICY_CHECK"
rule_title := "ECR Public Repository should deny PutImage and BatchPutImage actions"
rule_description := "Ensures ECR Public repositories have policies that deny PutImage or BatchPutImage actions to prevent unauthorized image uploads"
rule_severity := "HIGH"

# Main rule evaluation
deny contains msg if {
    # Find ECR public repositories
    ecr_repo := input.resources[_]
    ecr_repo.type == "aws_ecrpublic_repository"
    
    # Find associated repository policies
    policy_resource := input.resources[_]
    policy_resource.type == "aws_ecrpublic_repository_policy"
    
    # Check if policy is associated with the repository
    policy_targets_repo(policy_resource, ecr_repo)
    
    # Parse the policy document
    policy_doc := get_policy_document(policy_resource)
    
    # Check if policy contains PutImage or BatchPutImage actions with Allow effect
    has_allow_putimage_statement(policy_doc)
    
    msg := sprintf("ECR Public Repository '%s' has a policy that allows PutImage or BatchPutImage actions. This should be denied for security.", [ecr_repo.values.repository_name])
}

# Also check data sources for IAM policy documents directly
deny contains msg if {
    # Find ECR public repositories
    ecr_repo := input.resources[_]
    ecr_repo.type == "aws_ecrpublic_repository"
    
    # Find IAM policy documents that might be used
    policy_data := input.resources[_]
    policy_data.type == "aws_iam_policy_document"
    
    # Check if any policy document has Allow effect with PutImage/BatchPutImage
    has_allow_putimage_statement_in_data(policy_data)
    
    # Check if this policy document is referenced by a repository policy
    is_policy_used_by_ecr_repo(policy_data, ecr_repo)
    
    msg := sprintf("ECR Public Repository '%s' uses an IAM policy document that allows PutImage or BatchPutImage actions. This should be denied for security.", [ecr_repo.values.repository_name])
}

# Helper function to check if policy targets the repository
policy_targets_repo(policy_resource, ecr_repo) if {
    policy_resource.values.repository_name == ecr_repo.values.repository_name
}

policy_targets_repo(policy_resource, ecr_repo) if {
    # Handle terraform references like aws_ecrpublic_repository.example.repository_name
    contains(policy_resource.values.repository_name, ecr_repo.name)
}

# Helper function to get policy document from various sources
get_policy_document(policy_resource) := policy_doc if {
    # Direct JSON policy
    policy_doc := json.unmarshal(policy_resource.values.policy)
}

get_policy_document(policy_resource) := policy_doc if {
    # Policy from data source reference
    policy_ref := policy_resource.values.policy
    contains(policy_ref, "data.aws_iam_policy_document")
    
    # Extract the data source name
    data_source_ref := extract_data_source_name(policy_ref)
    data_source := input.resources[_]
    data_source.type == "aws_iam_policy_document"
    data_source.name == data_source_ref
    
    policy_doc := construct_policy_from_data_source(data_source)
}

# Helper function to extract data source name from reference
extract_data_source_name(ref) := name if {
    # Extract from "data.aws_iam_policy_document.example.json"
    parts := split(ref, ".")
    count(parts) >= 3
    name := parts[2]
}

# Helper function to construct policy document from Terraform data source
construct_policy_from_data_source(data_source) := {
    "Version": "2012-10-17",
    "Statement": [statement |
        stmt := data_source.values.statement[_]
        statement := {
            "Sid": stmt.sid,
            "Effect": stmt.effect,
            "Principal": construct_principal(stmt.principals),
            "Action": stmt.actions
        }
    ]
}

# Helper function to construct principal from Terraform format
construct_principal(principals) := principal if {
    principal := {principals[0].type: principals[0].identifiers}
}

construct_principal(principals) := "*" if {
    principals[0].identifiers[0] == "*"
}

# Check if policy document has Allow statements for PutImage/BatchPutImage
has_allow_putimage_statement(policy_doc) if {
    statement := policy_doc.Statement[_]
    statement.Effect == "Allow"
    action := statement.Action[_]
    putimage_actions := {"ecr-public:PutImage", "ecr-public:BatchPutImage"}
    putimage_actions[action]
}

# Check data source directly for Allow statements
has_allow_putimage_statement_in_data(policy_data) if {
    statement := policy_data.values.statement[_]
    statement.effect == "Allow"
    action := statement.actions[_]
    putimage_actions := {"ecr-public:PutImage", "ecr-public:BatchPutImage"}
    putimage_actions[action]
}

# Check if policy document is used by ECR repository
is_policy_used_by_ecr_repo(policy_data, ecr_repo) if {
    # Find repository policy that references this data source
    repo_policy := input.resources[_]
    repo_policy.type == "aws_ecrpublic_repository_policy"
    policy_targets_repo(repo_policy, ecr_repo)
    
    # Check if policy references the data source
    policy_ref := repo_policy.values.policy
    contains(policy_ref, policy_data.name)
}

# Rule passes when:
# 1. No ECR public repositories exist, OR
# 2. ECR repositories exist but have proper Deny policies for PutImage/BatchPutImage, OR  
# 3. ECR repositories exist without any policies (default deny)
allow if {
    count([r | r := input.resources[_]; r.type == "aws_ecrpublic_repository"]) == 0
}

allow if {
    ecr_repos := [r | r := input.resources[_]; r.type == "aws_ecrpublic_repository"]
    count(ecr_repos) > 0
    
    # All ECR repositories should either have no policy or have proper Deny policies
    all_repos_compliant
}

# Check if all repositories are compliant
all_repos_compliant if {
    ecr_repos := [r | r := input.resources[_]; r.type == "aws_ecrpublic_repository"]
    compliant_repos := [repo |
        repo := ecr_repos[_]
        repo_is_compliant(repo)
    ]
    count(ecr_repos) == count(compliant_repos)
}

# A repository is compliant if:
# 1. It has no associated policy (default deny), OR
# 2. It has a policy that denies PutImage/BatchPutImage, OR
# 3. It has a policy that doesn't mention PutImage/BatchPutImage at all
repo_is_compliant(repo) if {
    not has_policy_with_allow_putimage(repo)
}

# Check if repository has a policy that allows PutImage/BatchPutImage
has_policy_with_allow_putimage(repo) if {
    policy_resource := input.resources[_]
    policy_resource.type == "aws_ecrpublic_repository_policy"
    policy_targets_repo(policy_resource, repo)
    
    policy_doc := get_policy_document(policy_resource)
    has_allow_putimage_statement(policy_doc)
}

has_policy_with_allow_putimage(repo) if {
    policy_data := input.resources[_]
    policy_data.type == "aws_iam_policy_document"
    has_allow_putimage_statement_in_data(policy_data)
    is_policy_used_by_ecr_repo(policy_data, repo)
}
