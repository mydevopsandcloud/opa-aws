package aws_transfer_server_security

import data.generic.common as common_lib
import data.generic.terraform as tf_lib

# Rule 1: Check for wildcard actions in IAM policies (s3:*, logs:*)
deny_wildcard_actions[result] {
    resource_types := {"aws_iam_policy", "aws_iam_role_policy", "aws_iam_user_policy", "aws_iam_group_policy"}
    resource := input.document[i].resource[resource_types[idx]][name]
    policy := common_lib.json_unmarshal(resource.policy)
    statements := common_lib.get_statement(policy)
    statement := statements[_]
    common_lib.is_allow_effect(statement)
    action := statement.Action[_]
    contains(action, "*")
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": resource_types[idx],
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("%s[%s].policy", [resource_types[idx], name]),
        "issueType": "LeastPrivilegeViolation",
        "severity": "HIGH",
        "title": "AWS Transfer Server IAM Policy Uses Wildcard Actions",
        "description": sprintf("IAM policy contains wildcard action '%s' which violates least privilege principle", [action]),
        "keyExpectedValue": "IAM policy should use specific actions instead of wildcards",
        "keyActualValue": sprintf("IAM policy contains wildcard action: %s", [action]),
        "searchLine": common_lib.build_search_line(["resource", resource_types[idx], name, "policy"], []),
        "remediation": "Replace wildcard actions with specific required actions like 's3:GetObject', 's3:PutObject', 'logs:CreateLogStream'"
    }
}

# Rule 2: Check for wildcard resources in IAM policies (Resource: "*")
deny_wildcard_resources[result] {
    resource_types := {"aws_iam_policy", "aws_iam_role_policy", "aws_iam_user_policy", "aws_iam_group_policy"}
    resource := input.document[i].resource[resource_types[idx]][name]
    policy := common_lib.json_unmarshal(resource.policy)
    statements := common_lib.get_statement(policy)
    statement := statements[_]
    common_lib.is_allow_effect(statement)
    common_lib.equalsOrInArray(statement.Resource, "*")
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": resource_types[idx],
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("%s[%s].policy", [resource_types[idx], name]),
        "issueType": "LeastPrivilegeViolation",
        "severity": "HIGH",
        "title": "AWS Transfer Server IAM Policy Uses Wildcard Resources",
        "description": "IAM policy contains wildcard resource '*' which violates least privilege principle",
        "keyExpectedValue": "IAM policy should specify exact resource ARNs",
        "keyActualValue": "IAM policy contains wildcard resource: '*'",
        "searchLine": common_lib.build_search_line(["resource", resource_types[idx], name, "policy"], []),
        "remediation": "Replace '*' with specific resource ARNs like 'arn:aws:s3:::my-transfer-bucket' and 'arn:aws:logs:region:account:log-group:*'"
    }
}

# Rule 3: Check for proper AWS Transfer Server role trust policy
deny_incorrect_trust_policy[result] {
    resource := input.document[i].resource.aws_iam_role[name]
    # Check if this role is used by Transfer Server
    some j
    transfer_server := input.document[j].resource.aws_transfer_server[_]
    transfer_server.logging_role == sprintf("aws_iam_role.%s.arn", [name])
    
    policy := common_lib.json_unmarshal(resource.assume_role_policy)
    statements := common_lib.get_statement(policy)
    statement := statements[_]
    
    not statement.Principal.Service == "transfer.amazonaws.com"
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": "aws_iam_role",
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("aws_iam_role[%s].assume_role_policy", [name]),
        "issueType": "SecurityMisconfiguration",
        "severity": "MEDIUM",
        "title": "AWS Transfer Server Role Missing Correct Trust Policy",
        "description": "IAM role used by Transfer Server must trust 'transfer.amazonaws.com' service",
        "keyExpectedValue": "Principal.Service should be 'transfer.amazonaws.com'",
        "keyActualValue": sprintf("Principal.Service is '%v'", [statement.Principal.Service]),
        "searchLine": common_lib.build_search_line(["resource", "aws_iam_role", name, "assume_role_policy"], []),
        "remediation": "Set Principal.Service to 'transfer.amazonaws.com' in the assume role policy"
    }
}

# Rule 4: Validate required minimum actions for Transfer Server
allow_required_actions[result] {
    resource := input.document[i].resource.aws_iam_policy[name]
    policy := common_lib.json_unmarshal(resource.policy)
    statements := common_lib.get_statement(policy)
    
    # Required actions for Transfer Server
    required_s3_actions := {"s3:ListBucket", "s3:GetObject", "s3:PutObject", "s3:DeleteObject"}
    required_log_actions := {"logs:CreateLogGroup", "logs:CreateLogStream", "logs:PutLogEvents"}
    
    # Check if policy has required S3 actions
    has_s3_actions := count([action | 
        statement := statements[_]
        action := statement.Action[_]
        action in required_s3_actions
    ]) >= 3
    
    # Check if policy has required log actions  
    has_log_actions := count([action |
        statement := statements[_]
        action := statement.Action[_]
        action in required_log_actions
    ]) >= 1
    
    has_s3_actions
    has_log_actions
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": "aws_iam_policy",
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("aws_iam_policy[%s].policy", [name]),
        "issueType": "BestPractice",
        "severity": "INFO",
        "title": "AWS Transfer Server IAM Policy Has Required Actions",
        "description": "IAM policy contains the minimum required actions for Transfer Server operation",
        "status": "PASS"
    }
}

# Rule 5: Check for missing Transfer Server configuration
deny_missing_transfer_server[result] {
    # Check if IAM role exists but no Transfer Server uses it
    resource := input.document[i].resource.aws_iam_role[name]
    
    # Check if role name suggests it's for Transfer Server
    contains(lower(name), "transfer")
    
    # Check if no Transfer Server references this role
    not transfer_server_uses_role(name)
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": "aws_iam_role",
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("aws_iam_role[%s]", [name]),
        "issueType": "ConfigurationIssue",
        "severity": "MEDIUM",
        "title": "Transfer Server Role Not Used",
        "description": "IAM role appears to be for Transfer Server but is not referenced by any Transfer Server resource",
        "keyExpectedValue": "Transfer Server role should be used by an aws_transfer_server resource",
        "keyActualValue": "Role is not referenced by any Transfer Server",
        "remediation": "Ensure this role is used in the logging_role parameter of an aws_transfer_server resource"
    }
}

# Helper function to check if Transfer Server uses the role
transfer_server_uses_role(role_name) {
    some i, j
    transfer_server := input.document[i].resource.aws_transfer_server[j]
    transfer_server.logging_role == sprintf("aws_iam_role.%s.arn", [role_name])
}

# Rule 6: Check Transfer Server security configurations
deny_insecure_transfer_server[result] {
    resource := input.document[i].resource.aws_transfer_server[name]
    
    # Check for insecure endpoint type (should prefer VPC_ENDPOINT for production)
    resource.endpoint_type == "PUBLIC"
    
    result := {
        "documentId": input.document[i].id,
        "resourceType": "aws_transfer_server",
        "resourceName": tf_lib.get_resource_name(resource, name),
        "searchKey": sprintf("aws_transfer_server[%s].endpoint_type", [name]),
        "issueType": "SecurityRecommendation",
        "severity": "LOW",
        "title": "Transfer Server Uses Public Endpoint",
        "description": "Transfer Server is configured with PUBLIC endpoint which may expose it to internet traffic",
        "keyExpectedValue": "Consider using 'VPC_ENDPOINT' for enhanced security",
        "keyActualValue": "endpoint_type is 'PUBLIC'",
        "remediation": "Consider changing endpoint_type to 'VPC_ENDPOINT' for production environments"
    }
}

# Aggregate all denial rules
deny[result] {
    result := deny_wildcard_actions[_]
}

deny[result] {
    result := deny_wildcard_resources[_]
}

deny[result] {
    result := deny_incorrect_trust_policy[_]
}

deny[result] {
    result := deny_missing_transfer_server[_]
}

deny[result] {
    result := deny_insecure_transfer_server[_]
}

# Aggregate all allow rules
allow[result] {
    result := allow_required_actions[_]
}
